<!DOCTYPE html>
<html>
<head>
    <title>micro:bit Voice Calendar</title>
    <meta charset="utf-8">
    <style>
        body {
            font-family: 'Sarabun', Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .status {
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: bold;
            text-align: center;
        }
        .status.ready { background: #e8f5e8; color: #2d5a3d; }
        .status.connected { background: #e3f2fd; color: #1565c0; }
        .status.listening { background: #fff3e0; color: #e65100; }
        .status.error { background: #ffebee; color: #c62828; }
        .status.success { background: #e8f5e8; color: #2e7d32; }
        
        .buttons {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .btn {
            padding: 12px 20px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .btn.primary { background: #1976d2; color: white; }
        .btn.danger { background: #d32f2f; color: white; }
        .btn.secondary { background: #757575; color: white; }
        
        .info-box {
            background: #f0f0f0;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #1976d2;
        }
        .examples-box {
            background: #e8f4fd;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #2196f3;
        }
        .result-box {
            margin-top: 20px;
            padding: 15px;
            background: #e8f5e8;
            border-radius: 8px;
            border-left: 4px solid #4caf50;
        }
        .debug-box {
            margin-top: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé§ ‡∏£‡∏∞‡∏ö‡∏ö‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á Google Calendar</h1>
        
        <div id="status" class="status ready">‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô - ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ micro:bit</div>
        
        <div class="buttons">
            <button onclick="connectMicrobit()" class="btn primary">
                üîó ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ micro:bit
            </button>
            <button onclick="disconnectMicrobit()" class="btn danger">
                ‚ùå ‡∏ï‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
            </button>
            <button onclick="startListening()" class="btn secondary">
                üé§ ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á
            </button>
            <button onclick="testWebhook()" class="btn secondary">
                üîß ‡∏ó‡∏î‡∏™‡∏≠‡∏ö Zapier
            </button>
        </div>
        
        <div class="info-box">
            <h3>‡∏ß‡∏¥‡∏ò‡∏µ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô:</h3>
            <p><strong>‡∏õ‡∏∏‡πà‡∏° A:</strong> ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á (‡∏à‡∏∞‡∏ô‡∏±‡∏ö‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)</p>
            <p><strong>‡∏õ‡∏∏‡πà‡∏° B:</strong> ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô</p>
            <p><strong>‡∏õ‡∏∏‡πà‡∏° A+B:</strong> ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠</p>
        </div>
        
        <div class="examples-box">
            <h3>‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á:</h3>
            <ul>
                <li>"‡∏à‡∏î‡∏õ‡∏£‡∏∞‡∏ä‡∏∏‡∏°‡∏ó‡∏µ‡∏°‡∏û‡∏£‡∏∏‡πà‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏ß‡∏•‡∏≤ 2 ‡πÇ‡∏°‡∏á‡∏ö‡πà‡∏≤‡∏¢"</li>
                <li>"‡∏à‡∏î‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ß‡∏±‡∏ô‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå‡πÄ‡∏ß‡∏•‡∏≤ 10 ‡πÇ‡∏°‡∏á‡πÄ‡∏ä‡πâ‡∏≤"</li>
                <li>"‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏õ‡∏£‡∏∞‡∏ä‡∏∏‡∏°‡∏û‡∏£‡∏∏‡πà‡∏á‡∏ô‡∏µ‡πâ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô 3 ‡πÇ‡∏°‡∏á"</li>
                <li>"‡∏•‡∏ö‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢‡∏•‡∏π‡∏Å‡∏Ñ‡πâ‡∏≤‡∏ß‡∏±‡∏ô‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå"</li>
            </ul>
        </div>
        
        <div id="result"></div>
        <div id="debug"></div>
    </div>
    
    <script>
        // Global variables
        let port = null;
        let reader = null;
        let recognition = null;
        let isConnected = false;
        
        // ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó status display
        function updateStatus(message, type = 'ready') {
            const statusEl = document.getElementById('status');
            statusEl.innerHTML = message;
            statusEl.className = `status ${type}`;
        }
        
        // ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• debug
        function showDebug(message) {
            const debugEl = document.getElementById('debug');
            const timestamp = new Date().toLocaleTimeString('th-TH');
            debugEl.innerHTML = `<div class="debug-box">[${timestamp}] ${message}</div>`;
        }
        
        // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö Webhook
        async function testWebhook() {
            const testData = {
                action: 'create',
                title: '‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏£‡∏∞‡∏ö‡∏ö',
                start_datetime: new Date().toISOString(),
                end_datetime: new Date(Date.now() + 60*60*1000).toISOString(),
                timezone: 'Asia/Bangkok',
                description: '‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Zapier',
                duration_minutes: 60
            };
            
            updateStatus('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏î‡∏™‡∏≠‡∏ö Zapier...', 'listening');
            
            try {
                const response = await fetch('https://hooks.zapier.com/hooks/catch/24425708/uhfcmta/', {
                    method: 'POST',
                    mode: 'no-cors', // ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á CORS
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(testData)
                });
                
                // ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ no-cors ‡πÄ‡∏£‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö response ‡πÑ‡∏î‡πâ
                updateStatus('‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡πÑ‡∏õ‡∏¢‡∏±‡∏á Zapier ‡πÅ‡∏•‡πâ‡∏ß (no-cors mode)', 'success');
                showDebug('‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ' + JSON.stringify(testData, null, 2));
                
            } catch (error) {
                console.error('Test webhook error:', error);
                updateStatus('‡∏ó‡∏î‡∏™‡∏≠‡∏ö Zapier ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: ' + error.message, 'error');
                showDebug('Error: ' + error.message);
            }
        }
        
        // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ micro:bit
        async function connectMicrobit() {
            try {
                if (!('serial' in navigator)) {
                    updateStatus('‡∏ö‡∏£‡∏≤‡∏ß‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Web Serial API', 'error');
                    showDebug('Web Serial API ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö - ‡πÉ‡∏ä‡πâ Chrome ‡∏´‡∏£‡∏∑‡∏≠ Edge ‡πÅ‡∏ó‡∏ô');
                    return;
                }
                
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200 });
                
                updateStatus('‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ micro:bit ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!', 'connected');
                isConnected = true;
                
                const textDecoder = new TextDecoderStream();
                const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
                reader = textDecoder.readable.getReader();
                
                readSerialData();
                
            } catch (error) {
                console.error('Connection error:', error);
                updateStatus('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ micro:bit ‡πÑ‡∏î‡πâ: ' + error.message, 'error');
                showDebug('Connection Error: ' + error.message);
                isConnected = false;
            }
        }
        
        // ‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å Serial
        async function readSerialData() {
            try {
                while (isConnected && reader) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    
                    console.log('Received from micro:bit:', value);
                    showDebug('‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å micro:bit: ' + value);
                    
                    if (value.includes('START_LISTENING')) {
                        updateStatus('micro:bit ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á...', 'listening');
                        startListening();
                        
                    } else if (value.includes('STOP_LISTENING')) {
                        updateStatus('‡∏´‡∏¢‡∏∏‡∏î‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏•‡πâ‡∏ß', 'ready');
                        stopListening();
                        
                    } else if (value.includes('CANCEL')) {
                        updateStatus('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô', 'ready');
                        stopListening();
                        
                    } else if (value.includes('TEST_CONNECTION')) {
                        updateStatus('‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ - ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!', 'success');
                        showDebug('‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
                    }
                }
            } catch (error) {
                console.error('Serial read error:', error);
                updateStatus('‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•: ' + error.message, 'error');
                showDebug('Serial Error: ' + error.message);
            }
        }
        
        // ‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
        async function disconnectMicrobit() {
            try {
                isConnected = false;
                if (reader) {
                    await reader.cancel();
                    reader = null;
                }
                if (port) {
                    await port.close();
                    port = null;
                }
                updateStatus('‡∏ï‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡πâ‡∏ß', 'ready');
            } catch (error) {
                console.error('Disconnect error:', error);
                updateStatus('‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠: ' + error.message, 'error');
            }
        }
        
        // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á
        function startListening() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            if (!SpeechRecognition) {
                updateStatus('‡∏ö‡∏£‡∏≤‡∏ß‡πÄ‡∏ã‡∏≠‡∏£‡πå‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Speech Recognition', 'error');
                showDebug('Speech Recognition ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö - ‡πÉ‡∏ä‡πâ Chrome ‡πÅ‡∏ó‡∏ô');
                return;
            }
            
            recognition = new SpeechRecognition();
            recognition.lang = 'th-TH';
            recognition.continuous = false;
            recognition.interimResults = false;
            
            recognition.onstart = function() {
                updateStatus('üé§ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ü‡∏±‡∏á...', 'listening');
            };
            
            recognition.onresult = function(event) {
                const transcript = event.results[0][0].transcript;
                showDebug('‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á: ' + transcript);
                document.getElementById('result').innerHTML = `<div class="result-box">‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á: "${transcript}"</div>`;
                processVoiceCommand(transcript);
            };
            
            recognition.onerror = function(event) {
                console.error('Speech Recognition Error:', event.error);
                updateStatus('‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + event.error, 'error');
                showDebug('Speech Error: ' + event.error);
            };
            
            recognition.onend = function() {
                updateStatus('‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô', 'ready');
            };
            
            recognition.start();
        }
        
        function stopListening() {
            if (recognition) {
                recognition.stop();
            }
        }
        
        // ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á
        function processVoiceCommand(command) {
            const eventData = parseCalendarCommand(command);
            if (eventData) {
                sendToZapier(eventData);
            }
        }
        
        // ‡πÅ‡∏õ‡∏•‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°
        function parseCalendarCommand(command) {
            console.log('Processing command:', command);
            const lowerCommand = command.toLowerCase();
            
            let action = 'create';
            let title = '';
            let datetime = '';
            let eventId = '';
            let duration = 60;
            
            if (lowerCommand.includes('‡∏à‡∏î') || lowerCommand.includes('‡πÄ‡∏û‡∏¥‡πà‡∏°') || 
                lowerCommand.includes('‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢') || lowerCommand.includes('‡∏õ‡∏£‡∏∞‡∏ä‡∏∏‡∏°')) {
                
                action = 'create';
                title = extractEventTitle(lowerCommand);
                const timeData = extractDateTime(lowerCommand);
                datetime = timeData.datetime;
                duration = timeData.duration;
                
            } else if (lowerCommand.includes('‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç') || lowerCommand.includes('‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô') ||
                      lowerCommand.includes('‡∏¢‡πâ‡∏≤‡∏¢') || lowerCommand.includes('‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô')) {
                
                action = 'update';
                title = extractEventTitle(lowerCommand);
                const timeData = extractDateTime(lowerCommand);
                datetime = timeData.datetime;
                
            } else if (lowerCommand.includes('‡∏•‡∏ö') || lowerCommand.includes('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å') ||
                      lowerCommand.includes('‡πÑ‡∏°‡πà‡πÄ‡∏≠‡∏≤')) {
                
                action = 'delete';
                title = extractEventTitle(lowerCommand);
                datetime = extractDateTime(lowerCommand).datetime;
            }
            
            if (!title) {
                title = '‡∏á‡∏≤‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç';
            }
            
            return {
                action: action,
                title: title,
                datetime: datetime,
                duration: duration,
                event_id: eventId,
                original_command: command,
                timezone: 'Asia/Bangkok'
            };
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°
        function extractEventTitle(command) {
            let title = '';
            
            const patterns = [
                /‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á\s*(.+?)(?=\s*(‡πÄ‡∏ß‡∏•‡∏≤|‡∏ß‡∏±‡∏ô|‡∏û‡∏£‡∏∏‡πà‡∏á‡∏ô‡∏µ‡πâ|‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ|$))/i,
                /‡∏õ‡∏£‡∏∞‡∏ä‡∏∏‡∏°\s*(.+?)(?=\s*(‡πÄ‡∏ß‡∏•‡∏≤|‡∏ß‡∏±‡∏ô|‡∏û‡∏£‡∏∏‡πà‡∏á‡∏ô‡∏µ‡πâ|‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ|$))/i,
                /‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢\s*(.+?)(?=\s*(‡πÄ‡∏ß‡∏•‡∏≤|‡∏ß‡∏±‡∏ô|‡∏û‡∏£‡∏∏‡πà‡∏á‡∏ô‡∏µ‡πâ|‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ|$))/i,
                /‡∏á‡∏≤‡∏ô\s*(.+?)(?=\s*(‡πÄ‡∏ß‡∏•‡∏≤|‡∏ß‡∏±‡∏ô|‡∏û‡∏£‡∏∏‡πà‡∏á‡∏ô‡∏µ‡πâ|‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ|$))/i,
                /‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°\s*(.+?)(?=\s*(‡πÄ‡∏ß‡∏•‡∏≤|‡∏ß‡∏±‡∏ô|‡∏û‡∏£‡∏∏‡πà‡∏á‡∏ô‡∏µ‡πâ|‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ|$))/i
            ];
            
            for (let pattern of patterns) {
                const match = command.match(pattern);
                if (match && match[1] && match[1].trim()) {
                    title = match[1].trim();
                    break;
                }
            }
            
            if (!title) {
                if (command.includes('‡∏õ‡∏£‡∏∞‡∏ä‡∏∏‡∏°')) title = '‡∏õ‡∏£‡∏∞‡∏ä‡∏∏‡∏°';
                else if (command.includes('‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢')) title = '‡∏ô‡∏±‡∏î‡∏´‡∏°‡∏≤‡∏¢';
                else if (command.includes('‡∏á‡∏≤‡∏ô')) title = '‡∏á‡∏≤‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç';
                else if (command.includes('‡πÄ‡∏£‡∏µ‡∏¢‡∏ô')) title = '‡πÄ‡∏£‡∏µ‡∏¢‡∏ô';
                else if (command.includes('‡∏ó‡∏≥‡∏á‡∏≤‡∏ô')) title = '‡∏ó‡∏≥‡∏á‡∏≤‡∏ô';
            }
            
            return title;
        }
        
        // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤
        function extractDateTime(command) {
            const now = new Date();
            let targetDate = new Date(now);
            let duration = 60;
            
            if (command.includes('‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ')) {
                targetDate = new Date(now);
            } else if (command.includes('‡∏û‡∏£‡∏∏‡πà‡∏á‡∏ô‡∏µ‡πâ')) {
                targetDate.setDate(now.getDate() + 1);
            } else if (command.includes('‡∏°‡∏∞‡∏£‡∏∑‡∏ô‡∏ô‡∏µ‡πâ')) {
                targetDate.setDate(now.getDate() + 2);
            } else if (command.includes('‡∏™‡∏±‡∏õ‡∏î‡∏≤‡∏´‡πå‡∏´‡∏ô‡πâ‡∏≤')) {
                targetDate.setDate(now.getDate() + 7);
            }
            
            const dayMap = {
                '‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå': 1, '‡∏ß‡∏±‡∏ô‡∏à‡∏±‡∏ô‡∏ó‡∏£‡πå': 1,
                '‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£': 2, '‡∏ß‡∏±‡∏ô‡∏≠‡∏±‡∏á‡∏Ñ‡∏≤‡∏£': 2,
                '‡∏û‡∏∏‡∏ò': 3, '‡∏ß‡∏±‡∏ô‡∏û‡∏∏‡∏ò': 3,
                '‡∏û‡∏§‡∏´‡∏±‡∏™‡∏ö‡∏î‡∏µ': 4, '‡∏û‡∏§‡∏´‡∏±‡∏™': 4, '‡∏ß‡∏±‡∏ô‡∏û‡∏§‡∏´‡∏±‡∏™‡∏ö‡∏î‡∏µ': 4,
                '‡∏®‡∏∏‡∏Å‡∏£‡πå': 5, '‡∏ß‡∏±‡∏ô‡∏®‡∏∏‡∏Å‡∏£‡πå': 5,
                '‡πÄ‡∏™‡∏≤‡∏£‡πå': 6, '‡∏ß‡∏±‡∏ô‡πÄ‡∏™‡∏≤‡∏£‡πå': 6,
                '‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå': 0, '‡∏ß‡∏±‡∏ô‡∏≠‡∏≤‡∏ó‡∏¥‡∏ï‡∏¢‡πå': 0
            };
            
            for (let [dayName, dayNum] of Object.entries(dayMap)) {
                if (command.includes(dayName)) {
                    const daysUntilTarget = (dayNum - now.getDay() + 7) % 7;
                    if (daysUntilTarget === 0 && !command.includes('‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ')) {
                        targetDate.setDate(now.getDate() + 7);
                    } else {
                        targetDate.setDate(now.getDate() + daysUntilTarget);
                    }
                    break;
                }
            }
            
            let hour = 9;
            let minute = 0;
            
            const timePatterns = [
                /(\d{1,2})[:.](\d{2})/g,
                /(\d{1,2})\s*‡πÇ‡∏°‡∏á\s*(\d{1,2})\s*‡∏ô‡∏≤‡∏ó‡∏µ/g,
                /(\d{1,2})\s*‡πÇ‡∏°‡∏á\s*‡∏Ñ‡∏£‡∏∂‡πà‡∏á/g,
                /(\d{1,2})\s*‡πÇ‡∏°‡∏á/g,
                /(\d{1,2})\s*‡∏ô‡∏≤‡∏¨‡∏¥‡∏Å‡∏≤/g,
            ];
            
            for (let pattern of timePatterns) {
                const matches = Array.from(command.matchAll(pattern));
                if (matches.length > 0) {
                    const match = matches[0];
                    hour = parseInt(match[1]);
                    
                    if (match[2] !== undefined) {
                        if (pattern.source.includes('‡∏Ñ‡∏£‡∏∂‡πà‡∏á')) {
                            minute = 30;
                        } else {
                            minute = parseInt(match[2]);
                        }
                    }
                    break;
                }
            }
            
            if (command.includes('‡πÄ‡∏ä‡πâ‡∏≤') && hour > 12) {
                hour = hour - 12;
            } else if (command.includes('‡∏ö‡πà‡∏≤‡∏¢') || command.includes('‡πÄ‡∏¢‡πá‡∏ô')) {
                if (hour < 12 && hour !== 0) {
                    hour = hour + 12;
                }
            } else if (command.includes('‡∏Ñ‡πà‡∏≥') || command.includes('‡∏Å‡∏•‡∏≤‡∏á‡∏Ñ‡∏∑‡∏ô')) {
                if (hour < 12) {
                    hour = hour + 12;
                }
            }
            
            if (command.includes('1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á') || command.includes('‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á')) {
                duration = 60;
            } else if (command.includes('30 ‡∏ô‡∏≤‡∏ó‡∏µ') || command.includes('‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á')) {
                duration = 30;
            } else if (command.includes('2 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á')) {
                duration = 120;
            }
            
            const durationMatch = command.match(/(\d+)\s*‡∏ô‡∏≤‡∏ó‡∏µ/);
            if (durationMatch) {
                duration = parseInt(durationMatch[1]);
            }
            
            targetDate.setHours(hour, minute, 0, 0);
            
            return {
                datetime: targetDate.toISOString(),
                duration: duration
            };
        }
        
        // ‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á Zapier (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÅ‡∏•‡πâ‡∏ß)
        async function sendToZapier(eventData) {
            const webhookUrls = {
                'create': 'https://hooks.zapier.com/hooks/catch/24425708/uhfcmta/',
                'update': 'https://hooks.zapier.com/hooks/catch/24425708/uhf032l/', 
                'delete': 'https://hooks.zapier.com/hooks/catch/24425708/uhfpkrz/'
            };
            
            const webhookUrl = webhookUrls[eventData.action];
            
            if (!webhookUrl) {
                updateStatus('‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏∞‡∏ó‡∏≥‡∏ô‡∏µ‡πâ', 'error');
                return;
            }
            
            const zapierData = {
                action: eventData.action,
                title: eventData.title,
                start_datetime: eventData.datetime,
                end_datetime: calculateEndDateTime(eventData.datetime, eventData.duration),
                timezone: eventData.timezone || 'Asia/Bangkok',
                description: `‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏î‡∏¢‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á: "${eventData.original_command}"`,
                duration_minutes: eventData.duration,
                event_id: eventData.event_id,
                search_title: eventData.title,
                search_date: eventData.datetime.split('T')[0]
            };
            
            try {
                updateStatus(`‡∏Å‡∏≥‡∏•‡∏±‡∏á${getActionText(eventData.action)}...`, 'listening');
                showDebug('‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ Zapier: ' + JSON.stringify(zapierData, null, 2));
                
                // ‡∏•‡∏≠‡∏á‡∏™‡πà‡∏á‡πÅ‡∏ö‡∏ö‡∏õ‡∏Å‡∏ï‡∏¥‡∏Å‡πà‡∏≠‡∏ô
                let response;
                try {
                    response = await fetch(webhookUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(zapierData)
                    });
                } catch (corsError) {
                    // ‡∏ñ‡πâ‡∏≤ CORS error ‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á‡πÉ‡∏ä‡πâ no-cors mode
                    console.log('CORS error, trying no-cors mode...');
                    showDebug('‡πÄ‡∏Å‡∏¥‡∏î CORS error, ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏õ‡πá‡∏ô no-cors mode');
                    
                    response = await fetch(webhookUrl, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(zapierData)
                    });
                }
                
                // ‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
                const actionText = getActionText(eventData.action);
                updateStatus(`${actionText}‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! "${eventData.title}"`, 'success');
                
                const datetime = new Date(eventData.datetime);
                const displayTime = datetime.toLocaleString('th-TH', {
                    timeZone: 'Asia/Bangkok',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                document.getElementById('result').innerHTML = `
                    <div class="result-box">
                        <h4>‚úÖ ${actionText}‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!</h4>
                        <strong>‡∏ä‡∏∑‡πà‡∏≠‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°:</strong> ${eventData.title}<br>
                        <strong>‡∏ß‡∏±‡∏ô‡πÄ‡∏ß‡∏•‡∏≤:</strong> ${displayTime}<br>
                        <strong>‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤:</strong> ${eventData.duration} ‡∏ô‡∏≤‡∏ó‡∏µ<br>
                        <strong>‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á:</strong> "${eventData.original_command}"
                    </div>
                `;
                
                showDebug('‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
                
            } catch (error) {
                console.error('Error sending to Zapier:', error);
                updateStatus('‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Å‡∏±‡∏ö Zapier ‡πÑ‡∏î‡πâ: ' + error.message, 'error');
                showDebug('Zapier Error: ' + error.message + '\nURL: ' + webhookUrl);
                
                // ‡πÅ‡∏™‡∏î‡∏á‡∏ß‡∏¥‡∏ò‡∏µ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
                document.getElementById('result').innerHTML = `
                    <div class="result-box" style="background: #ffebee; border-left-color: #f44336;">
                        <h4>‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î</h4>
                        <p><strong>‡∏™‡∏≤‡πÄ‡∏´‡∏ï‡∏∏:</strong> ${error.message}</p>
                        <p><strong>‡∏ß‡∏¥‡∏ò‡∏µ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç:</strong></p>
                        <ul>
                            <li>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Internet connection</li>
                            <li>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö Zapier Webhook URLs</li>
                            <li>‡∏•‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏ß‡πá‡∏ö‡πÑ‡∏ã‡∏ï‡πå‡πÉ‡∏ô Chrome ‡∏´‡∏£‡∏∑‡∏≠ Edge</li>
                            <li>‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Zap ‡πÉ‡∏ô Zapier ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏≠‡∏¢‡∏π‡πà</li>
                        </ul>
                    </div>
                `;
            }
        }
        
        // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏¥‡πâ‡∏ô‡∏™‡∏∏‡∏î
        function calculateEndDateTime(startDateTime, durationMinutes) {
            const endDate = new Date(startDateTime);
            endDate.setMinutes(endDate.getMinutes() + durationMinutes);
            return endDate.toISOString();
        }
        
        // ‡πÅ‡∏õ‡∏•‡∏á action ‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏ó‡∏¢
        function getActionText(action) {
            const actionMap = {
                'create': '‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°',
                'update': '‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°', 
                'delete': '‡∏•‡∏ö‡∏Å‡∏¥‡∏à‡∏Å‡∏£‡∏£‡∏°'
            };
            return actionMap[action] || '‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£';
        }
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢
        function checkNetworkStatus() {
            if (!navigator.onLine) {
                updateStatus('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï', 'error');
                return false;
            }
            return true;
        }
        
        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠
        async function testConnection() {
            if (!checkNetworkStatus()) return;
            
            try {
                updateStatus('‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠...', 'listening');
                
                // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏î‡πâ‡∏ß‡∏¢ simple GET request ‡∏Å‡πà‡∏≠‡∏ô
                const testResponse = await fetch('https://httpbin.org/get', {
                    method: 'GET',
                    mode: 'cors'
                });
                
                if (testResponse.ok) {
                    updateStatus('‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏≠‡∏¥‡∏ô‡πÄ‡∏ó‡∏≠‡∏£‡πå‡πÄ‡∏ô‡πá‡∏ï‡∏õ‡∏Å‡∏ï‡∏¥', 'success');
                    showDebug('‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢‡∏õ‡∏Å‡∏ï‡∏¥ - ‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏≠‡∏≤‡∏à‡∏≠‡∏¢‡∏π‡πà‡∏ó‡∏µ‡πà Zapier Webhook');
                }
                
            } catch (error) {
                updateStatus('‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢', 'error');
                showDebug('Network Error: ' + error.message);
            }
        }
        
        // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
        window.addEventListener('load', function() {
            showDebug('‡∏£‡∏∞‡∏ö‡∏ö‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô');
            
            // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö APIs
            const support = {
                'Web Serial': 'serial' in navigator,
                'Speech Recognition': !!(window.SpeechRecognition || window.webkitSpeechRecognition),
                'Fetch API': 'fetch' in window
            };
            
            let supportInfo = '‡∏Å‡∏≤‡∏£‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Browser APIs:<br>';
            for (let [api, supported] of Object.entries(support)) {
                supportInfo += `${api}: ${supported ? '‚úÖ ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö' : '‚ùå ‡πÑ‡∏°‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö'}<br>`;
            }
            
            showDebug(supportInfo);
        });
    </script>
</body>
</html>